// Minimal local fallback markdown parser (not full marked). Provides `window.marked.parse`.
(function(){
  function escapeHtml(s){return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}

  function parse(md){
    if(!md) return '';
    // code blocks ```
    md = md.replace(/```([\s\S]*?)```/g, function(_, code){
      return '<pre><code>'+escapeHtml(code)+'</code></pre>'
    })
    // headings
    md = md.replace(/^### (.*$)/gim, '<h3>$1</h3>')
    md = md.replace(/^## (.*$)/gim, '<h2>$1</h2>')
    md = md.replace(/^# (.*$)/gim, '<h1>$1</h1>')
    // bold/italic
    md = md.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    md = md.replace(/\*(.*?)\*/g, '<em>$1</em>')
    // inline code
    md = md.replace(/`([^`]+)`/g, '<code>$1</code>')
    // links
    md = md.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>')
    // unordered lists
    md = md.replace(/(^|\n)([-*] .+(?:\n[-*] .+)*)/g, function(_, nl, block){
      const items = block.split(/\n/).map(l=>l.replace(/^[-*] /,'')).map(i=>'<li>'+i+'</li>').join('')
      return nl + '<ul>'+items+'</ul>'
    })
    // paragraphs
    md = md.replace(/\n{2,}/g, '</p><p>')
    // wrap lines in p if not already block
    const lines = md.split(/\n/).map(l=>l.trim())
    let out = ''
    let inP = false
    for(const line of lines){
      if(line==='') { if(inP){ out += '</p>'; inP=false } ; continue }
      if(/^<h|^<ul|^<pre|^<\/h|^<\/ul|^<pre/.test(line)){
        if(inP){ out += '</p>'; inP=false }
        out += line
      } else {
        if(!inP){ out += '<p>'; inP=true }
        out += line + '\n'
      }
    }
    if(inP) out += '</p>'
    return out
  }

  window.marked = { parse }
})();
